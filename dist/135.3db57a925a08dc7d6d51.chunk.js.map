{"version":3,"file":"135.3db57a925a08dc7d6d51.chunk.js","mappings":"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","sources":["webpack://ignite-fitness/./js/core/data-store.js"],"sourcesContent":["// Data Store Module\n// Centralized data management with smart caching and conflict resolution\n\nclass DataStore {\n  constructor() {\n    this.logger = window.SafeLogger || console;\n    this.cache = new Map();\n    this.pendingWrites = new Map();\n    this.syncQueue = [];\n    this.isOnline = navigator.onLine;\n    this.conflictResolution = 'timestamp'; // local, remote, merge, timestamp\n    this.cacheExpiry = 5 * 60 * 1000; // 5 minutes\n    this.maxCacheSize = 1000;\n\n    // Listen for online/offline events\n    window.addEventListener('online', () => this.handleOnline());\n    window.addEventListener('offline', () => this.handleOffline());\n\n    // Start sync interval\n    setInterval(() => this.processSyncQueue(), 30000); // Every 30 seconds\n  }\n\n  // Get data with caching\n  async get(key, options = {}) {\n    const { useCache = true, forceRefresh = false } = options;\n\n    // Check cache first\n    if (useCache && !forceRefresh) {\n      const cached = this.cache.get(key);\n      if (cached && Date.now() - cached.timestamp < this.cacheExpiry) {\n        return cached.data;\n      }\n    }\n\n    // Fetch from source\n    try {\n      const data = await this.fetchFromSource(key);\n\n      // Cache the result\n      this.cache.set(key, {\n        data,\n        timestamp: Date.now(),\n      });\n\n      return data;\n    } catch (error) {\n      this.logger.error('Error fetching data', { key, error: error.message, stack: error.stack });\n\n      // Return cached data if available\n      const cached = this.cache.get(key);\n      if (cached) {\n        return cached.data;\n      }\n\n      throw error;\n    }\n  }\n\n  // Set data with conflict resolution\n  async set(key, data, options = {}) {\n    const { priority = 'local', conflictResolution = this.conflictResolution } = options;\n\n    // Check for conflicts\n    const existing = this.cache.get(key);\n    if (existing && this.hasConflict(existing.data, data)) {\n      const resolved = this.resolveConflict(existing.data, data, conflictResolution);\n      data = resolved;\n    }\n\n    // Store in cache\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n      priority,\n    });\n\n    // Queue for sync if online\n    if (this.isOnline) {\n      this.syncQueue.push({ key, data, timestamp: Date.now() });\n    } else {\n      // Store pending write\n      this.pendingWrites.set(key, { data, timestamp: Date.now() });\n    }\n\n    // Save to localStorage as backup\n    this.saveToLocalStorage(key, data);\n  }\n\n  // Fetch from source (localStorage or API)\n  async fetchFromSource(key) {\n    // Try localStorage first\n    const localData = this.loadFromLocalStorage(key);\n    if (localData) {\n      return localData;\n    }\n\n    // Try API if online\n    if (this.isOnline) {\n      try {\n        return await this.fetchFromAPI(key);\n      } catch (error) {\n        this.logger.warn('API fetch failed, using local data', { key, error: error.message });\n        return localData;\n      }\n    }\n\n    return localData;\n  }\n\n  // Load from localStorage\n  loadFromLocalStorage(key) {\n    try {\n      const data = localStorage.getItem(`ignitefitness_${key}`);\n      return data ? JSON.parse(data) : null;\n    } catch (error) {\n      this.logger.error('Error loading from localStorage', {\n        key,\n        error: error.message,\n        stack: error.stack,\n      });\n      return null;\n    }\n  }\n\n  // Save to localStorage\n  saveToLocalStorage(key, data) {\n    try {\n      localStorage.setItem(`ignitefitness_${key}`, JSON.stringify(data));\n    } catch (error) {\n      this.logger.error('Error saving to localStorage', {\n        key,\n        error: error.message,\n        stack: error.stack,\n      });\n    }\n  }\n\n  // Fetch from API\n  async fetchFromAPI(key) {\n    const endpoints = {\n      user_data: '/.netlify/functions/get-user-data',\n      sessions: '/.netlify/functions/sessions-list',\n      all_users: '/.netlify/functions/admin-get-all-users',\n    };\n\n    const endpoint = endpoints[key];\n    if (!endpoint) {\n      throw new Error(`No API endpoint for key: ${key}`);\n    }\n\n    const response = await fetch(endpoint, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    });\n\n    if (!response.ok) {\n      throw new Error(`API request failed: ${response.status}`);\n    }\n\n    return await response.json();\n  }\n\n  // Check for data conflicts\n  hasConflict(existing, incoming) {\n    // Simple conflict detection based on timestamp\n    if (existing.timestamp && incoming.timestamp) {\n      const timeDiff = Math.abs(existing.timestamp - incoming.timestamp);\n      return timeDiff > 1000; // 1 second threshold\n    }\n    return false;\n  }\n\n  // Resolve conflicts\n  resolveConflict(existing, incoming, strategy) {\n    switch (strategy) {\n      case 'local':\n        return existing;\n      case 'remote':\n        return incoming;\n      case 'merge':\n        return this.mergeData(existing, incoming);\n      case 'timestamp':\n      default:\n        return existing.timestamp > incoming.timestamp ? existing : incoming;\n    }\n  }\n\n  // Merge data objects\n  mergeData(existing, incoming) {\n    const merged = { ...existing };\n\n    for (const key in incoming) {\n      if (incoming[key] !== undefined) {\n        if (typeof incoming[key] === 'object' && !Array.isArray(incoming[key])) {\n          merged[key] = this.mergeData(existing[key] || {}, incoming[key]);\n        } else {\n          merged[key] = incoming[key];\n        }\n      }\n    }\n\n    return merged;\n  }\n\n  // Process sync queue\n  async processSyncQueue() {\n    if (!this.isOnline || this.syncQueue.length === 0) {\n      return;\n    }\n\n    const batch = this.syncQueue.splice(0, 10); // Process 10 items at a time\n\n    for (const item of batch) {\n      try {\n        await this.syncToAPI(item.key, item.data);\n      } catch (error) {\n        this.logger.error('Sync failed', {\n          key: item.key,\n          error: error.message,\n          stack: error.stack,\n        });\n        // Re-queue for retry\n        this.syncQueue.push(item);\n      }\n    }\n  }\n\n  // Sync to API\n  async syncToAPI(key, data) {\n    const endpoints = {\n      user_data: '/.netlify/functions/save-user-data',\n      sessions: '/.netlify/functions/sessions-create',\n      preferences: '/.netlify/functions/save-user-data',\n      goals: '/.netlify/functions/save-user-data',\n      workout_schedule: '/.netlify/functions/save-user-data',\n      strava_activities: '/.netlify/functions/save-user-data',\n    };\n\n    const endpoint = endpoints[key];\n    if (!endpoint) {\n      throw new Error(`No sync endpoint for key: ${key}`);\n    }\n\n    // Prepare data for database sync based on data type\n    let requestBody;\n    if (key === 'user_data') {\n      requestBody = {\n        userId: this.currentUser,\n        dataType: 'all',\n        data,\n      };\n    } else if (['preferences', 'goals', 'workout_schedule', 'strava_activities'].includes(key)) {\n      requestBody = {\n        userId: this.currentUser,\n        dataType: key,\n        data,\n      };\n    } else {\n      requestBody = data;\n    }\n\n    try {\n      const response = await fetch(endpoint, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(requestBody),\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        let errorMessage = `Sync failed: ${response.status}`;\n\n        try {\n          const errorData = JSON.parse(errorText);\n          errorMessage += ` - ${errorData.error || errorText}`;\n        } catch {\n          errorMessage += ` - ${errorText}`;\n        }\n\n        throw new Error(errorMessage);\n      }\n\n      const result = await response.json();\n      this.logger.info('Successfully synced to database', { key, result });\n\n      // Update last sync time\n      this.lastSyncTime = Date.now();\n      localStorage.setItem('ignitefitness_last_sync', this.lastSyncTime.toString());\n\n      return result;\n    } catch (error) {\n      this.logger.error('Sync error', { key, error: error.message, stack: error.stack });\n\n      // If it's a network error, queue for retry\n      if (error.name === 'TypeError' || error.message.includes('fetch')) {\n        throw new Error(`Network error: ${error.message}`);\n      }\n\n      // For other errors, re-throw\n      throw error;\n    }\n  }\n\n  // Handle online event\n  handleOnline() {\n    this.isOnline = true;\n    this.updateSyncStatus();\n\n    // Process pending writes\n    for (const [key, write] of this.pendingWrites) {\n      this.syncQueue.push({ key, data: write.data, timestamp: write.timestamp });\n    }\n    this.pendingWrites.clear();\n  }\n\n  // Handle offline event\n  handleOffline() {\n    this.isOnline = false;\n    this.updateSyncStatus();\n  }\n\n  // Update sync status indicator\n  updateSyncStatus() {\n    const indicator = document.getElementById('sync-status');\n    if (indicator) {\n      indicator.textContent = this.isOnline ? 'ðŸŸ¢ Online' : 'ðŸ”´ Offline';\n      indicator.style.color = this.isOnline ? '#68d391' : '#fc8181';\n    }\n  }\n\n  // Clear cache\n  clearCache() {\n    this.cache.clear();\n  }\n\n  // Get cache statistics\n  getCacheStats() {\n    return {\n      size: this.cache.size,\n      maxSize: this.maxCacheSize,\n      pendingWrites: this.pendingWrites.size,\n      syncQueue: this.syncQueue.length,\n      isOnline: this.isOnline,\n    };\n  }\n}\n\n// Export for use in other modules\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = { DataStore };\n} else {\n  // Make available globally for browser\n  window.DataStore = DataStore;\n}\n"],"names":["DataStore","constructor","this","logger","window","SafeLogger","console","cache","Map","pendingWrites","syncQueue","isOnline","navigator","onLine","conflictResolution","cacheExpiry","maxCacheSize","addEventListener","handleOnline","handleOffline","setInterval","processSyncQueue","get","key","options","useCache","forceRefresh","cached","Date","now","timestamp","data","fetchFromSource","set","error","message","stack","priority","existing","hasConflict","resolveConflict","push","saveToLocalStorage","localData","loadFromLocalStorage","fetchFromAPI","warn","localStorage","getItem","JSON","parse","setItem","stringify","endpoint","user_data","sessions","all_users","Error","response","fetch","method","headers","ok","status","json","incoming","Math","abs","strategy","mergeData","merged","undefined","Array","isArray","length","batch","splice","item","syncToAPI","preferences","goals","workout_schedule","strava_activities","requestBody","userId","currentUser","dataType","includes","body","errorText","text","errorMessage","result","info","lastSyncTime","toString","name","updateSyncStatus","write","clear","indicator","document","getElementById","textContent","style","color","clearCache","getCacheStats","size","maxSize","module","exports"],"sourceRoot":""}