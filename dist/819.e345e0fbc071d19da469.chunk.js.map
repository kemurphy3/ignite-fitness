{"version":3,"file":"819.e345e0fbc071d19da469.chunk.js","mappings":"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","sources":["webpack://ignite-fitness/./js/ai/pattern-detector.js"],"sourcesContent":["// Pattern Detection System\n// Analyzes user workout patterns, performance trends, and behavioral insights\n\nclass PatternDetector {\n  constructor() {\n    this.logger = window.SafeLogger || console;\n    this.patterns = {\n      performance: {},\n      timing: {},\n      volume: {},\n      intensity: {},\n      recovery: {},\n      progression: {},\n    };\n\n    this.insights = [];\n    this.recommendations = [];\n  }\n\n  // Analyze user patterns from workout data\n  analyzePatterns(workoutData, userProfile) {\n    this.patterns = {\n      performance: this.analyzePerformancePatterns(workoutData),\n      timing: this.analyzeTimingPatterns(workoutData),\n      volume: this.analyzeVolumePatterns(workoutData),\n      intensity: this.analyzeIntensityPatterns(workoutData),\n      recovery: this.analyzeRecoveryPatterns(workoutData),\n      progression: this.analyzeProgressionPatterns(workoutData),\n    };\n\n    this.generateInsights();\n    this.generateRecommendations(userProfile);\n\n    return {\n      patterns: this.patterns,\n      insights: this.insights,\n      recommendations: this.recommendations,\n    };\n  }\n\n  // Analyze performance patterns\n  analyzePerformancePatterns(workoutData) {\n    const sessions = workoutData.sessions || [];\n    if (sessions.length < 3) {\n      return {};\n    }\n\n    const patterns = {\n      dayOfWeek: this.analyzeDayOfWeekPerformance(sessions),\n      timeOfDay: this.analyzeTimeOfDayPerformance(sessions),\n      exercisePerformance: this.analyzeExercisePerformance(sessions),\n      consistency: this.calculateConsistency(sessions),\n      improvement: this.calculateImprovement(sessions),\n    };\n\n    return patterns;\n  }\n\n  // Analyze day-of-week performance patterns\n  analyzeDayOfWeekPerformance(sessions) {\n    const dayPerformance = {};\n\n    for (let i = 0; i < 7; i++) {\n      dayPerformance[i] = {\n        count: 0,\n        totalRPE: 0,\n        averageRPE: 0,\n        totalVolume: 0,\n        averageVolume: 0,\n      };\n    }\n\n    sessions.forEach(session => {\n      const dayOfWeek = new Date(session.start_at).getDay();\n      const rpe = session.averageRPE || 0;\n      const volume = this.calculateSessionVolume(session);\n\n      dayPerformance[dayOfWeek].count++;\n      dayPerformance[dayOfWeek].totalRPE += rpe;\n      dayPerformance[dayOfWeek].totalVolume += volume;\n    });\n\n    // Calculate averages\n    Object.keys(dayPerformance).forEach(day => {\n      const data = dayPerformance[day];\n      if (data.count > 0) {\n        data.averageRPE = data.totalRPE / data.count;\n        data.averageVolume = data.totalVolume / data.count;\n      }\n    });\n\n    return dayPerformance;\n  }\n\n  // Analyze time-of-day performance patterns\n  analyzeTimeOfDayPerformance(sessions) {\n    const timePerformance = {\n      morning: { count: 0, totalRPE: 0, averageRPE: 0 },\n      afternoon: { count: 0, totalRPE: 0, averageRPE: 0 },\n      evening: { count: 0, totalRPE: 0, averageRPE: 0 },\n    };\n\n    sessions.forEach(session => {\n      const hour = new Date(session.start_at).getHours();\n      const timeSlot = hour < 12 ? 'morning' : hour < 17 ? 'afternoon' : 'evening';\n      const rpe = session.averageRPE || 0;\n\n      timePerformance[timeSlot].count++;\n      timePerformance[timeSlot].totalRPE += rpe;\n    });\n\n    // Calculate averages\n    Object.keys(timePerformance).forEach(time => {\n      const data = timePerformance[time];\n      if (data.count > 0) {\n        data.averageRPE = data.totalRPE / data.count;\n      }\n    });\n\n    return timePerformance;\n  }\n\n  // Analyze exercise-specific performance\n  analyzeExercisePerformance(sessions) {\n    const exerciseStats = {};\n\n    sessions.forEach(session => {\n      if (session.exercises) {\n        session.exercises.forEach(exercise => {\n          if (!exerciseStats[exercise.name]) {\n            exerciseStats[exercise.name] = {\n              count: 0,\n              totalWeight: 0,\n              totalReps: 0,\n              totalSets: 0,\n              averageWeight: 0,\n              averageReps: 0,\n              averageSets: 0,\n              progression: [],\n            };\n          }\n\n          const stats = exerciseStats[exercise.name];\n          stats.count++;\n          stats.totalWeight += exercise.weight || 0;\n          stats.totalReps += exercise.reps || 0;\n          stats.totalSets += exercise.sets || 0;\n          stats.progression.push({\n            date: session.start_at,\n            weight: exercise.weight || 0,\n            reps: exercise.reps || 0,\n            sets: exercise.sets || 0,\n          });\n        });\n      }\n    });\n\n    // Calculate averages and progression\n    Object.keys(exerciseStats).forEach(exercise => {\n      const stats = exerciseStats[exercise];\n      if (stats.count > 0) {\n        stats.averageWeight = stats.totalWeight / stats.count;\n        stats.averageReps = stats.totalReps / stats.count;\n        stats.averageSets = stats.totalSets / stats.count;\n        stats.progression = this.calculateExerciseProgression(stats.progression);\n      }\n    });\n\n    return exerciseStats;\n  }\n\n  // Calculate workout consistency\n  calculateConsistency(sessions) {\n    if (!sessions || sessions.length < 7) {\n      return 0;\n    }\n\n    try {\n      const last30Days = sessions.filter(session => {\n        if (!session || !session.start_at) {\n          return false;\n        }\n        const sessionDate = new Date(session.start_at);\n        if (isNaN(sessionDate.getTime())) {\n          return false;\n        }\n\n        const thirtyDaysAgo = new Date();\n        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n        return sessionDate >= thirtyDaysAgo;\n      });\n\n      // Calculate expected workouts based on actual frequency (more realistic than daily)\n      const expectedFrequency = 3; // Default: 3 workouts per week\n      const expectedWorkouts = (expectedFrequency / 7) * 30; // ~12.9 workouts in 30 days\n      const actualWorkouts = last30Days.length;\n\n      // Return ratio (capped at 1.0)\n      return Math.min(1.0, actualWorkouts / expectedWorkouts);\n    } catch (error) {\n      this.logger.error('Error calculating consistency', {\n        error: error.message,\n        stack: error.stack,\n      });\n      return 0;\n    }\n  }\n\n  // Calculate improvement over time\n  calculateImprovement(sessions) {\n    if (!sessions || sessions.length < 4) {\n      return 0;\n    }\n\n    try {\n      // Filter out invalid sessions\n      const validSessions = sessions.filter(\n        s => s && s.start_at && !isNaN(new Date(s.start_at).getTime())\n      );\n      if (validSessions.length < 4) {\n        return 0;\n      }\n\n      const sortedSessions = [...validSessions].sort(\n        (a, b) => new Date(a.start_at) - new Date(b.start_at)\n      );\n      const firstHalf = sortedSessions.slice(0, Math.floor(sortedSessions.length / 2));\n      const secondHalf = sortedSessions.slice(Math.floor(sortedSessions.length / 2));\n\n      const firstHalfVolume = firstHalf.reduce(\n        (sum, session) => sum + this.calculateSessionVolume(session),\n        0\n      );\n      const secondHalfVolume = secondHalf.reduce(\n        (sum, session) => sum + this.calculateSessionVolume(session),\n        0\n      );\n\n      if (firstHalfVolume === 0) {\n        return 0;\n      }\n\n      return (secondHalfVolume - firstHalfVolume) / firstHalfVolume;\n    } catch (error) {\n      this.logger.error('Error calculating improvement', {\n        error: error.message,\n        stack: error.stack,\n      });\n      return 0;\n    }\n  }\n\n  // Analyze timing patterns\n  analyzeTimingPatterns(workoutData) {\n    const sessions = workoutData.sessions || [];\n    if (sessions.length < 3) {\n      return {};\n    }\n\n    return {\n      preferredDays: this.getPreferredDays(sessions),\n      preferredTimes: this.getPreferredTimes(sessions),\n      sessionFrequency: this.calculateSessionFrequency(sessions),\n      restDayPattern: this.analyzeRestDayPattern(sessions),\n    };\n  }\n\n  // Get preferred workout days\n  getPreferredDays(sessions) {\n    const dayCounts = {};\n\n    for (let i = 0; i < 7; i++) {\n      dayCounts[i] = 0;\n    }\n\n    sessions.forEach(session => {\n      const dayOfWeek = new Date(session.start_at).getDay();\n      dayCounts[dayOfWeek]++;\n    });\n\n    return Object.entries(dayCounts)\n      .sort(([, a], [, b]) => b - a)\n      .map(([day, count]) => ({ day: parseInt(day), count }));\n  }\n\n  // Get preferred workout times\n  getPreferredTimes(sessions) {\n    const timeCounts = { morning: 0, afternoon: 0, evening: 0 };\n\n    sessions.forEach(session => {\n      const hour = new Date(session.start_at).getHours();\n      const timeSlot = hour < 12 ? 'morning' : hour < 17 ? 'afternoon' : 'evening';\n      timeCounts[timeSlot]++;\n    });\n\n    return Object.entries(timeCounts)\n      .sort(([, a], [, b]) => b - a)\n      .map(([time, count]) => ({ time, count }));\n  }\n\n  // Calculate session frequency\n  calculateSessionFrequency(sessions) {\n    if (sessions.length < 2) {\n      return 0;\n    }\n\n    const firstSession = new Date(Math.min(...sessions.map(s => new Date(s.start_at))));\n    const lastSession = new Date(Math.max(...sessions.map(s => new Date(s.start_at))));\n    const daysDiff = (lastSession - firstSession) / (1000 * 60 * 60 * 24);\n\n    return sessions.length / Math.max(1, daysDiff);\n  }\n\n  // Analyze rest day patterns\n  analyzeRestDayPattern(sessions) {\n    const restDays = [];\n    const sortedSessions = sessions.sort((a, b) => new Date(a.start_at) - new Date(b.start_at));\n\n    for (let i = 1; i < sortedSessions.length; i++) {\n      const current = new Date(sortedSessions[i].start_at);\n      const previous = new Date(sortedSessions[i - 1].start_at);\n      const daysDiff = (current - previous) / (1000 * 60 * 60 * 24);\n\n      if (daysDiff > 1) {\n        restDays.push(daysDiff - 1);\n      }\n    }\n\n    return {\n      averageRestDays:\n        restDays.length > 0 ? restDays.reduce((sum, days) => sum + days, 0) / restDays.length : 0,\n      maxRestDays: restDays.length > 0 ? Math.max(...restDays) : 0,\n      minRestDays: restDays.length > 0 ? Math.min(...restDays) : 0,\n    };\n  }\n\n  // Analyze volume patterns\n  analyzeVolumePatterns(workoutData) {\n    const sessions = workoutData.sessions || [];\n    if (sessions.length < 3) {\n      return {};\n    }\n\n    const volumes = sessions.map(session => this.calculateSessionVolume(session));\n\n    return {\n      averageVolume: this.calculateAverage(volumes),\n      volumeTrend: this.calculateTrend(volumes),\n      volumeVariability: this.calculateVariability(volumes),\n      peakVolume: Math.max(...volumes),\n      lowVolume: Math.min(...volumes),\n    };\n  }\n\n  // Analyze intensity patterns\n  analyzeIntensityPatterns(workoutData) {\n    const sessions = workoutData.sessions || [];\n    if (sessions.length < 3) {\n      return {};\n    }\n\n    const rpeValues = sessions.map(session => session.averageRPE || 0).filter(rpe => rpe > 0);\n\n    return {\n      averageRPE: this.calculateAverage(rpeValues),\n      rpeTrend: this.calculateTrend(rpeValues),\n      rpeVariability: this.calculateVariability(rpeValues),\n      maxRPE: Math.max(...rpeValues),\n      minRPE: Math.min(...rpeValues),\n    };\n  }\n\n  // Analyze recovery patterns\n  analyzeRecoveryPatterns(workoutData) {\n    const sessions = workoutData.sessions || [];\n    if (sessions.length < 3) {\n      return {};\n    }\n\n    return {\n      recoveryTime: this.calculateAverageRecoveryTime(sessions),\n      fatiguePattern: this.analyzeFatiguePattern(sessions),\n      overtrainingRisk: this.assessOvertrainingRisk(sessions),\n    };\n  }\n\n  // Analyze progression patterns\n  analyzeProgressionPatterns(workoutData) {\n    const sessions = workoutData.sessions || [];\n    if (sessions.length < 3) {\n      return {};\n    }\n\n    return {\n      strengthProgression: this.calculateStrengthProgression(sessions),\n      volumeProgression: this.calculateVolumeProgression(sessions),\n      consistencyProgression: this.calculateConsistencyProgression(sessions),\n    };\n  }\n\n  // Calculate session volume\n  calculateSessionVolume(session) {\n    if (!session.exercises) {\n      return 0;\n    }\n\n    return session.exercises.reduce((total, exercise) => {\n      const weight = exercise.weight || 0;\n      const reps = exercise.reps || 0;\n      const sets = exercise.sets || 0;\n      return total + weight * reps * sets;\n    }, 0);\n  }\n\n  // Calculate exercise progression\n  calculateExerciseProgression(progressionData) {\n    if (progressionData.length < 2) {\n      return 0;\n    }\n\n    const sorted = progressionData.sort((a, b) => new Date(a.date) - new Date(b.date));\n    const first = sorted[0];\n    const last = sorted[sorted.length - 1];\n\n    const firstVolume = first.weight * first.reps * first.sets;\n    const lastVolume = last.weight * last.reps * last.sets;\n\n    if (firstVolume === 0) {\n      return 0;\n    }\n\n    return (lastVolume - firstVolume) / firstVolume;\n  }\n\n  // Calculate average\n  calculateAverage(values) {\n    if (values.length === 0) {\n      return 0;\n    }\n    return values.reduce((sum, value) => sum + value, 0) / values.length;\n  }\n\n  // Calculate trend\n  calculateTrend(values) {\n    if (values.length < 2) {\n      return 0;\n    }\n\n    const firstHalf = values.slice(0, Math.floor(values.length / 2));\n    const secondHalf = values.slice(Math.floor(values.length / 2));\n\n    const firstAvg = this.calculateAverage(firstHalf);\n    const secondAvg = this.calculateAverage(secondHalf);\n\n    if (firstAvg === 0) {\n      return 0;\n    }\n\n    return (secondAvg - firstAvg) / firstAvg;\n  }\n\n  // Calculate variability (coefficient of variation)\n  calculateVariability(values) {\n    if (values.length < 2) {\n      return 0;\n    }\n\n    const average = this.calculateAverage(values);\n    if (average === 0) {\n      return 0;\n    }\n\n    const variance =\n      values.reduce((sum, value) => sum + Math.pow(value - average, 2), 0) / values.length;\n    const standardDeviation = Math.sqrt(variance);\n\n    return standardDeviation / average;\n  }\n\n  // Calculate average recovery time\n  calculateAverageRecoveryTime(sessions) {\n    const sortedSessions = sessions.sort((a, b) => new Date(a.start_at) - new Date(b.start_at));\n    const recoveryTimes = [];\n\n    for (let i = 1; i < sortedSessions.length; i++) {\n      const current = new Date(sortedSessions[i].start_at);\n      const previous = new Date(sortedSessions[i - 1].start_at);\n      const hoursDiff = (current - previous) / (1000 * 60 * 60);\n      recoveryTimes.push(hoursDiff);\n    }\n\n    return this.calculateAverage(recoveryTimes);\n  }\n\n  // Analyze fatigue pattern\n  analyzeFatiguePattern(sessions) {\n    const sortedSessions = sessions.sort((a, b) => new Date(a.start_at) - new Date(b.start_at));\n    const rpeValues = sortedSessions.map(session => session.averageRPE || 0);\n\n    // Look for declining RPE over time (fatigue)\n    const trend = this.calculateTrend(rpeValues);\n    return {\n      fatigueTrend: trend,\n      isFatigued: trend < -0.1,\n      fatigueLevel: Math.abs(trend),\n    };\n  }\n\n  // Assess overtraining risk\n  assessOvertrainingRisk(sessions) {\n    const recentSessions = sessions.slice(-7); // Last 7 sessions\n    const averageRPE = this.calculateAverage(recentSessions.map(s => s.averageRPE || 0));\n    const sessionFrequency = this.calculateSessionFrequency(recentSessions);\n\n    let riskScore = 0;\n\n    // High RPE + High frequency = High risk\n    if (averageRPE > 8) {\n      riskScore += 3;\n    } else if (averageRPE > 7) {\n      riskScore += 2;\n    } else if (averageRPE > 6) {\n      riskScore += 1;\n    }\n\n    if (sessionFrequency > 6) {\n      riskScore += 3;\n    } else if (sessionFrequency > 4) {\n      riskScore += 2;\n    } else if (sessionFrequency > 2) {\n      riskScore += 1;\n    }\n\n    return {\n      riskScore,\n      riskLevel: riskScore >= 5 ? 'high' : riskScore >= 3 ? 'medium' : 'low',\n      factors: {\n        highIntensity: averageRPE > 7,\n        highFrequency: sessionFrequency > 4,\n        insufficientRecovery: this.calculateAverageRecoveryTime(recentSessions) < 24,\n      },\n    };\n  }\n\n  // Calculate strength progression\n  calculateStrengthProgression(sessions) {\n    const exerciseStats = this.analyzeExercisePerformance(sessions);\n    const progressions = Object.values(exerciseStats).map(stats => stats.progression);\n    const averageProgression = this.calculateAverage(progressions);\n\n    return {\n      averageProgression,\n      progressionLevel:\n        averageProgression > 0.1\n          ? 'excellent'\n          : averageProgression > 0.05\n            ? 'good'\n            : averageProgression > 0\n              ? 'moderate'\n              : 'poor',\n    };\n  }\n\n  // Calculate volume progression\n  calculateVolumeProgression(sessions) {\n    const volumes = sessions.map(session => this.calculateSessionVolume(session));\n    const trend = this.calculateTrend(volumes);\n\n    return {\n      trend,\n      progressionLevel: trend > 0.1 ? 'increasing' : trend > -0.1 ? 'stable' : 'decreasing',\n    };\n  }\n\n  // Calculate consistency progression\n  calculateConsistencyProgression(sessions) {\n    const consistency = this.calculateConsistency(sessions);\n\n    return {\n      consistency,\n      consistencyLevel:\n        consistency > 0.8\n          ? 'excellent'\n          : consistency > 0.6\n            ? 'good'\n            : consistency > 0.4\n              ? 'moderate'\n              : 'poor',\n    };\n  }\n\n  // Generate insights from patterns\n  generateInsights() {\n    this.insights = [];\n\n    try {\n      // Performance insights\n      if (this.patterns?.performance?.dayOfWeek) {\n        const dayEntries = Object.entries(this.patterns.performance.dayOfWeek)\n          .filter(([, data]) => data && data.count > 0 && data.averageRPE > 0)\n          .sort(([, a], [, b]) => (b.averageRPE || 0) - (a.averageRPE || 0));\n\n        if (dayEntries.length > 0) {\n          const bestDay = dayEntries[0];\n          const dayNumber = parseInt(bestDay[0]);\n          const dayData = bestDay[1];\n\n          if (!isNaN(dayNumber) && dayData.averageRPE > 0) {\n            this.insights.push({\n              type: 'performance',\n              message: `You perform best on ${this.getDayName(dayNumber)} with an average RPE of ${dayData.averageRPE.toFixed(1)}`,\n              priority: 'medium',\n              value: dayData.averageRPE,\n            });\n          }\n        }\n      }\n\n      // Timing insights\n      if (\n        this.patterns?.timing?.preferredTimes &&\n        Array.isArray(this.patterns.timing.preferredTimes)\n      ) {\n        const preferredTime = this.patterns.timing.preferredTimes.find(t => t && t.count > 0);\n        if (preferredTime) {\n          this.insights.push({\n            type: 'timing',\n            message: `You prefer working out in the ${preferredTime.time} (${preferredTime.count} sessions)`,\n            priority: 'low',\n            value: preferredTime.count,\n          });\n        }\n      }\n\n      // Volume insights\n      if (this.patterns?.volume && typeof this.patterns.volume.volumeTrend === 'number') {\n        const trend = this.patterns.volume.volumeTrend;\n        if (Math.abs(trend) > 0.1) {\n          this.insights.push({\n            type: 'volume',\n            message: `Your training volume is ${trend > 0 ? 'increasing' : 'decreasing'} by ${Math.abs(trend * 100).toFixed(1)}%`,\n            priority: 'high',\n            value: trend,\n          });\n        }\n      }\n\n      // Intensity insights\n      if (this.patterns?.intensity && typeof this.patterns.intensity.rpeTrend === 'number') {\n        const trend = this.patterns.intensity.rpeTrend;\n        if (Math.abs(trend) > 0.1) {\n          this.insights.push({\n            type: 'intensity',\n            message: `Your training intensity is ${trend > 0 ? 'increasing' : 'decreasing'} by ${Math.abs(trend * 100).toFixed(1)}%`,\n            priority: 'medium',\n            value: trend,\n          });\n        }\n      }\n\n      // Recovery insights\n      if (this.patterns?.recovery?.overtrainingRisk) {\n        const risk = this.patterns.recovery.overtrainingRisk;\n        if (risk && risk.riskLevel === 'high') {\n          this.insights.push({\n            type: 'recovery',\n            message:\n              'High risk of overtraining detected. Consider reducing intensity or frequency.',\n            priority: 'high',\n            value: risk.riskScore || 0,\n          });\n        }\n      }\n\n      // Consistency insights\n      if (this.patterns?.performance && typeof this.patterns.performance.consistency === 'number') {\n        const { consistency } = this.patterns.performance;\n        if (consistency < 0.5) {\n          this.insights.push({\n            type: 'consistency',\n            message: `Your workout consistency is ${(consistency * 100).toFixed(0)}%. Try to maintain a more regular schedule.`,\n            priority: 'medium',\n            value: consistency,\n          });\n        }\n      }\n    } catch (error) {\n      this.logger.error('Error generating insights', { error: error.message, stack: error.stack });\n    }\n  }\n\n  // Generate recommendations based on patterns\n  generateRecommendations(_userProfile) {\n    this.recommendations = [];\n\n    try {\n      // Consistency recommendations\n      if (this.patterns?.performance && typeof this.patterns.performance.consistency === 'number') {\n        const { consistency } = this.patterns.performance;\n        if (consistency < 0.6) {\n          this.recommendations.push({\n            type: 'consistency',\n            message: 'Try to maintain a more consistent workout schedule',\n            action: 'Set specific workout days and times',\n            priority: 'high',\n            value: consistency,\n          });\n        }\n      }\n\n      // Volume recommendations\n      if (this.patterns?.volume && typeof this.patterns.volume.volumeTrend === 'number') {\n        const trend = this.patterns.volume.volumeTrend;\n        if (trend < -0.1) {\n          this.recommendations.push({\n            type: 'volume',\n            message: 'Consider gradually increasing your training volume',\n            action: 'Add one more set or exercise to your workouts',\n            priority: 'medium',\n            value: trend,\n          });\n        } else if (trend > 0.2) {\n          this.recommendations.push({\n            type: 'volume',\n            message: 'Your volume is increasing rapidly. Monitor recovery closely.',\n            action: 'Consider adding a deload week if fatigue increases',\n            priority: 'medium',\n            value: trend,\n          });\n        }\n      }\n\n      // Recovery recommendations\n      if (this.patterns?.recovery?.overtrainingRisk) {\n        const risk = this.patterns.recovery.overtrainingRisk;\n        if (risk && risk.riskLevel === 'high') {\n          this.recommendations.push({\n            type: 'recovery',\n            message: 'Take a deload week to allow for proper recovery',\n            action: 'Reduce intensity by 20-30% for one week',\n            priority: 'high',\n            value: risk.riskScore || 0,\n          });\n        } else if (risk && risk.riskLevel === 'medium') {\n          this.recommendations.push({\n            type: 'recovery',\n            message: 'Consider adding an extra rest day or reducing intensity slightly',\n            action: 'Monitor readiness scores and adjust accordingly',\n            priority: 'medium',\n            value: risk.riskScore || 0,\n          });\n        }\n      }\n\n      // Progression recommendations\n      if (this.patterns?.progression?.strengthProgression) {\n        const strengthProg = this.patterns.progression.strengthProgression;\n        if (strengthProg && strengthProg.progressionLevel === 'poor') {\n          this.recommendations.push({\n            type: 'progression',\n            message: 'Focus on progressive overload to continue improving',\n            action: 'Increase weight or reps by 2-5% each week',\n            priority: 'high',\n            value: strengthProg.averageProgression || 0,\n          });\n        }\n      }\n\n      // Exercise variety recommendations\n      if (this.patterns?.performance?.exercisePerformance) {\n        const exerciseCount = Object.keys(this.patterns.performance.exercisePerformance).length;\n        if (exerciseCount < 5) {\n          this.recommendations.push({\n            type: 'variety',\n            message: 'Consider adding more exercise variety to your routine',\n            action: 'Try 2-3 new exercises that target different muscle groups',\n            priority: 'low',\n            value: exerciseCount,\n          });\n        }\n      }\n    } catch (error) {\n      this.logger.error('Error generating recommendations', {\n        error: error.message,\n        stack: error.stack,\n      });\n    }\n  }\n\n  // Get day name from number\n  getDayName(dayNumber) {\n    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n    return days[dayNumber];\n  }\n\n  // Get user patterns for display\n  getUserPatterns() {\n    return this.patterns;\n  }\n\n  // Get insights for display\n  getUserInsights() {\n    return this.insights;\n  }\n\n  // Get recommendations for display\n  getUserRecommendations() {\n    return this.recommendations;\n  }\n}\n\n// Export for use in other modules\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = { PatternDetector };\n} else {\n  // Make available globally for browser\n  window.PatternDetector = PatternDetector;\n}\n"],"names":["PatternDetector","constructor","this","logger","window","SafeLogger","console","patterns","performance","timing","volume","intensity","recovery","progression","insights","recommendations","analyzePatterns","workoutData","userProfile","analyzePerformancePatterns","analyzeTimingPatterns","analyzeVolumePatterns","analyzeIntensityPatterns","analyzeRecoveryPatterns","analyzeProgressionPatterns","generateInsights","generateRecommendations","sessions","length","dayOfWeek","analyzeDayOfWeekPerformance","timeOfDay","analyzeTimeOfDayPerformance","exercisePerformance","analyzeExercisePerformance","consistency","calculateConsistency","improvement","calculateImprovement","dayPerformance","i","count","totalRPE","averageRPE","totalVolume","averageVolume","forEach","session","Date","start_at","getDay","rpe","calculateSessionVolume","Object","keys","day","data","timePerformance","morning","afternoon","evening","hour","getHours","timeSlot","time","exerciseStats","exercises","exercise","name","totalWeight","totalReps","totalSets","averageWeight","averageReps","averageSets","stats","weight","reps","sets","push","date","calculateExerciseProgression","last30Days","filter","sessionDate","isNaN","getTime","thirtyDaysAgo","setDate","getDate","expectedWorkouts","actualWorkouts","Math","min","error","message","stack","validSessions","s","sortedSessions","sort","a","b","firstHalf","slice","floor","secondHalf","firstHalfVolume","reduce","sum","secondHalfVolume","preferredDays","getPreferredDays","preferredTimes","getPreferredTimes","sessionFrequency","calculateSessionFrequency","restDayPattern","analyzeRestDayPattern","dayCounts","entries","map","parseInt","timeCounts","firstSession","daysDiff","max","restDays","averageRestDays","days","maxRestDays","minRestDays","volumes","calculateAverage","volumeTrend","calculateTrend","volumeVariability","calculateVariability","peakVolume","lowVolume","rpeValues","rpeTrend","rpeVariability","maxRPE","minRPE","recoveryTime","calculateAverageRecoveryTime","fatiguePattern","analyzeFatiguePattern","overtrainingRisk","assessOvertrainingRisk","strengthProgression","calculateStrengthProgression","volumeProgression","calculateVolumeProgression","consistencyProgression","calculateConsistencyProgression","total","progressionData","sorted","first","last","firstVolume","lastVolume","values","value","firstAvg","secondAvg","average","variance","pow","sqrt","recoveryTimes","hoursDiff","trend","fatigueTrend","isFatigued","fatigueLevel","abs","recentSessions","riskScore","riskLevel","factors","highIntensity","highFrequency","insufficientRecovery","progressions","averageProgression","progressionLevel","consistencyLevel","_this$patterns","_this$patterns2","_this$patterns3","_this$patterns4","_this$patterns5","_this$patterns6","dayEntries","bestDay","dayNumber","dayData","type","getDayName","toFixed","priority","Array","isArray","preferredTime","find","t","risk","_userProfile","_this$patterns7","_this$patterns8","_this$patterns9","_this$patterns0","_this$patterns1","action","strengthProg","exerciseCount","getUserPatterns","getUserInsights","getUserRecommendations","module","exports"],"sourceRoot":""}