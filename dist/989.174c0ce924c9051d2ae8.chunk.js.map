{"version":3,"file":"989.174c0ce924c9051d2ae8.chunk.js","mappings":"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","sources":["webpack://ignite-fitness/./js/ai/context-aware-ai.js"],"sourcesContent":["// Context-Aware AI Module\n// Level 2 AI Implementation with user history and pattern detection\n\nclass ContextAwareAI {\n  constructor() {\n    this.logger = window.SafeLogger || console;\n    this.userHistory = this.loadUserHistory();\n    this.patterns = this.loadPatterns();\n    this.successMetrics = this.loadSuccessMetrics();\n    this.cache = new Map();\n    this.cacheExpiry = 5 * 60 * 1000; // 5 minutes\n    this.contextWindow = 10; // Last 10 interactions\n    this.costTracker = {\n      totalCost: 0,\n      calls: 0,\n      modelUsage: {},\n    };\n  }\n\n  // Load user history from localStorage\n  loadUserHistory() {\n    try {\n      const history = localStorage.getItem('ai_user_history');\n      return history\n        ? JSON.parse(history)\n        : {\n            interactions: [],\n            preferences: {},\n            patterns: {},\n            lastUpdated: Date.now(),\n          };\n    } catch (error) {\n      this.logger.error('Error loading user history', { error: error.message, stack: error.stack });\n      return { interactions: [], preferences: {}, patterns: {}, lastUpdated: Date.now() };\n    }\n  }\n\n  // Load patterns from localStorage\n  loadPatterns() {\n    try {\n      const patterns = localStorage.getItem('ai_patterns');\n      return patterns\n        ? JSON.parse(patterns)\n        : {\n            workoutPreferences: {},\n            responsePatterns: {},\n            successPatterns: {},\n            failurePatterns: {},\n          };\n    } catch (error) {\n      this.logger.error('Error loading patterns', { error: error.message, stack: error.stack });\n      return {\n        workoutPreferences: {},\n        responsePatterns: {},\n        successPatterns: {},\n        failurePatterns: {},\n      };\n    }\n  }\n\n  // Load success metrics from localStorage\n  loadSuccessMetrics() {\n    try {\n      const metrics = localStorage.getItem('ai_success_metrics');\n      return metrics\n        ? JSON.parse(metrics)\n        : {\n            workoutCompletions: 0,\n            goalAchievements: 0,\n            userSatisfaction: [],\n            responseEffectiveness: {},\n            lastUpdated: Date.now(),\n          };\n    } catch (error) {\n      this.logger.error('Error loading success metrics', {\n        error: error.message,\n        stack: error.stack,\n      });\n      return {\n        workoutCompletions: 0,\n        goalAchievements: 0,\n        userSatisfaction: [],\n        responseEffectiveness: {},\n        lastUpdated: Date.now(),\n      };\n    }\n  }\n\n  // Save user history\n  saveUserHistory() {\n    try {\n      localStorage.setItem('ai_user_history', JSON.stringify(this.userHistory));\n    } catch (error) {\n      this.logger.error('Error saving user history', { error: error.message, stack: error.stack });\n    }\n  }\n\n  // Save patterns\n  savePatterns() {\n    try {\n      localStorage.setItem('ai_patterns', JSON.stringify(this.patterns));\n    } catch (error) {\n      this.logger.error('Error saving patterns', { error: error.message, stack: error.stack });\n    }\n  }\n\n  // Save success metrics\n  saveSuccessMetrics() {\n    try {\n      localStorage.setItem('ai_success_metrics', JSON.stringify(this.successMetrics));\n    } catch (error) {\n      this.logger.error('Error saving success metrics', {\n        error: error.message,\n        stack: error.stack,\n      });\n    }\n  }\n\n  // Add interaction to history\n  addInteraction(userInput, aiResponse, context = {}) {\n    const interaction = {\n      timestamp: Date.now(),\n      userInput,\n      aiResponse,\n      context,\n      sessionId: this.getCurrentSessionId(),\n    };\n\n    this.userHistory.interactions.push(interaction);\n\n    // Keep only last 100 interactions\n    if (this.userHistory.interactions.length > 100) {\n      this.userHistory.interactions = this.userHistory.interactions.slice(-100);\n    }\n\n    this.userHistory.lastUpdated = Date.now();\n    this.saveUserHistory();\n\n    // Update patterns\n    this.updatePatterns(interaction);\n  }\n\n  // Get current session ID\n  getCurrentSessionId() {\n    let sessionId = sessionStorage.getItem('ai_session_id');\n    if (!sessionId) {\n      sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      sessionStorage.setItem('ai_session_id', sessionId);\n    }\n    return sessionId;\n  }\n\n  // Update patterns based on interaction\n  updatePatterns(interaction) {\n    const input = interaction.userInput.toLowerCase();\n    const response = interaction.aiResponse.toLowerCase();\n\n    // Detect workout preferences\n    if (input.includes('workout') || input.includes('exercise')) {\n      this.patterns.workoutPreferences[interaction.timestamp] = {\n        input,\n        context: interaction.context,\n        timestamp: interaction.timestamp,\n      };\n    }\n\n    // Detect response patterns\n    const responseType = this.categorizeResponse(response);\n    if (!this.patterns.responsePatterns[responseType]) {\n      this.patterns.responsePatterns[responseType] = [];\n    }\n    this.patterns.responsePatterns[responseType].push({\n      input,\n      response,\n      timestamp: interaction.timestamp,\n    });\n\n    this.savePatterns();\n  }\n\n  // Categorize response type\n  categorizeResponse(response) {\n    const lowerResponse = response.toLowerCase();\n\n    if (\n      lowerResponse.includes('workout') ||\n      lowerResponse.includes('exercise') ||\n      lowerResponse.includes('training') ||\n      lowerResponse.includes('gym')\n    ) {\n      return 'workout';\n    }\n    if (\n      lowerResponse.includes('nutrition') ||\n      lowerResponse.includes('diet') ||\n      lowerResponse.includes('eat') ||\n      lowerResponse.includes('food') ||\n      lowerResponse.includes('protein') ||\n      lowerResponse.includes('calories')\n    ) {\n      return 'nutrition';\n    }\n    if (\n      lowerResponse.includes('injury') ||\n      lowerResponse.includes('pain') ||\n      lowerResponse.includes('hurt') ||\n      lowerResponse.includes('ache') ||\n      lowerResponse.includes('rehabilitation')\n    ) {\n      return 'injury';\n    }\n    if (\n      lowerResponse.includes('schedule') ||\n      lowerResponse.includes('time') ||\n      lowerResponse.includes('when') ||\n      lowerResponse.includes('planning')\n    ) {\n      return 'schedule';\n    }\n    if (\n      lowerResponse.includes('goal') ||\n      lowerResponse.includes('progress') ||\n      lowerResponse.includes('achieve') ||\n      lowerResponse.includes('target')\n    ) {\n      return 'goal';\n    }\n\n    return 'workout'; // Default to workout category\n  }\n\n  // Get contextual context for AI\n  getContextualContext() {\n    const recentInteractions = this.userHistory.interactions.slice(-this.contextWindow);\n    const userProfile = this.getUserProfile();\n    const currentGoals = this.getCurrentGoals();\n    const recentWorkouts = this.getRecentWorkouts();\n    const seasonalContext = this.getSeasonalContext();\n\n    return {\n      recentInteractions,\n      userProfile,\n      currentGoals,\n      recentWorkouts,\n      seasonalContext,\n      patterns: this.patterns,\n      successMetrics: this.successMetrics,\n    };\n  }\n\n  // Get user profile from stored data\n  getUserProfile() {\n    try {\n      const userData = JSON.parse(localStorage.getItem('users') || '{}');\n      const currentUser = localStorage.getItem('ignitefitness_current_user');\n      return userData[currentUser] || {};\n    } catch (error) {\n      this.logger.error('Error getting user profile', { error: error.message, stack: error.stack });\n      return {};\n    }\n  }\n\n  // Get current goals\n  getCurrentGoals() {\n    const userProfile = this.getUserProfile();\n    return userProfile.goals || {};\n  }\n\n  // Get recent workouts\n  getRecentWorkouts() {\n    const userProfile = this.getUserProfile();\n    const sessions = userProfile.sessions || [];\n    return sessions.slice(-5); // Last 5 workouts\n  }\n\n  // Get seasonal context\n  getSeasonalContext() {\n    try {\n      const seasonalData = localStorage.getItem('seasonalPhase');\n      return seasonalData ? JSON.parse(seasonalData) : null;\n    } catch (error) {\n      return null;\n    }\n  }\n\n  // Generate contextual prompt\n  generateContextualPrompt(userInput, _context) {\n    const contextualContext = this.getContextualContext();\n\n    let prompt =\n      \"You are an AI fitness coach with deep knowledge of the user's history and preferences. \";\n\n    // Add user profile context\n    if (contextualContext.userProfile.name) {\n      prompt += `User: ${contextualContext.userProfile.name}. `;\n    }\n\n    // Add goals context\n    if (contextualContext.currentGoals.primary) {\n      prompt += `Primary goal: ${contextualContext.currentGoals.primary}. `;\n    }\n\n    // Add recent workout context\n    if (contextualContext.recentWorkouts.length > 0) {\n      const lastWorkout =\n        contextualContext.recentWorkouts[contextualContext.recentWorkouts.length - 1];\n      prompt += `Last workout: ${lastWorkout.type || 'Unknown'} on ${new Date(lastWorkout.start_at).toLocaleDateString()}. `;\n    }\n\n    // Add seasonal context\n    if (contextualContext.seasonalContext) {\n      prompt += `Current training phase: ${contextualContext.seasonalContext.phase}. `;\n    }\n\n    // Add recent interaction context\n    if (contextualContext.recentInteractions.length > 0) {\n      prompt += `Recent conversation topics: ${contextualContext.recentInteractions\n        .slice(-3)\n        .map(i => i.userInput)\n        .join(', ')}. `;\n    }\n\n    // Add patterns context\n    const responseType = this.categorizeResponse(userInput);\n    if (this.patterns.responsePatterns[responseType]) {\n      const recentPatterns = this.patterns.responsePatterns[responseType].slice(-3);\n      prompt += `Previous similar questions: ${recentPatterns.map(p => p.input).join(', ')}. `;\n    }\n\n    prompt += `\\n\\nUser's current question: \"${userInput}\"\\n\\nProvide a helpful, personalized response that considers their history and context.`;\n\n    return prompt;\n  }\n\n  // Process user input with context awareness\n  async processUserInput(userInput, context = {}) {\n    // Generate cache key\n    const cacheKey = this.generateCacheKey(userInput, context);\n\n    // Check cache first\n    const cachedResponse = this.getCachedResponse(cacheKey);\n    if (cachedResponse) {\n      return cachedResponse;\n    }\n\n    // Generate contextual prompt\n    const contextualPrompt = this.generateContextualPrompt(userInput, context);\n\n    // Select optimal model based on query complexity\n    const selectedModel = this.selectOptimalModel(userInput, context);\n\n    // Get AI response\n    const aiResponse = await this.getAIResponse(contextualPrompt, userInput, selectedModel);\n\n    // Cache response with smart invalidation\n    this.cacheResponse(cacheKey, aiResponse);\n\n    // Add to history\n    this.addInteraction(userInput, aiResponse, context);\n\n    // Track cost\n    const inputTokens = Math.ceil(contextualPrompt.length / 4);\n    const outputTokens = Math.ceil(aiResponse.length / 4);\n    this.trackCost(selectedModel, inputTokens, outputTokens);\n\n    return aiResponse;\n  }\n\n  // Get AI response (with fallback)\n  async getAIResponse(prompt, userInput, model) {\n    try {\n      // Try to call the AI proxy function\n      const response = await fetch('/.netlify/functions/ai-proxy', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          method: 'POST',\n          endpoint: '/openai/chat/completions',\n          data: {\n            model,\n            messages: [\n              {\n                role: 'system',\n                content:\n                  \"You are a knowledgeable fitness coach and nutritionist. Provide helpful, personalized advice based on the user's context and questions.\",\n              },\n              {\n                role: 'user',\n                content: prompt,\n              },\n            ],\n            max_tokens: 500,\n            temperature: 0.7,\n          },\n        }),\n      });\n\n      if (response.ok) {\n        const data = await response.json();\n        return (\n          data.choices?.[0]?.message?.content ||\n          \"I apologize, but I couldn't generate a response at this time.\"\n        );\n      } else {\n        this.logger.warn('AI API call failed, using fallback response', {\n          status: response.status,\n        });\n        const fallbackResult = this.getFallbackResponse(userInput);\n        return fallbackResult.message || fallbackResult;\n      }\n    } catch (error) {\n      this.logger.warn('AI API call error, using fallback response', {\n        error: error.message,\n        stack: error.stack,\n      });\n      const fallbackResult = this.getFallbackResponse(userInput);\n      return fallbackResult.message || fallbackResult;\n    }\n  }\n\n  // Fallback response system with deterministic selection\n  getFallbackResponse(userInput) {\n    const responses = {\n      workout: [\n        \"Based on your recent training and goals, I recommend focusing on compound movements today. Your last workout was upper body, so let's target lower body with squats, deadlifts, and lunges.\",\n        \"I see you've been consistent with your workouts! For today's session, let's build on your progress with some progressive overload on your main lifts.\",\n        'Given your athletic profile and recent performance, I suggest incorporating more explosive movements to improve your power output.',\n      ],\n      nutrition: [\n        'Based on your training schedule and goals, you should aim for 1.6-2.2g of protein per kg of body weight. Focus on timing your carbs around your workouts.',\n        \"I notice you've been training hard. Make sure you're getting enough calories to support your recovery and performance goals.\",\n        'Your macro targets look good, but consider adding more healthy fats for hormone production and recovery.',\n      ],\n      injury: [\n        \"I understand you're experiencing some discomfort. Let's modify your training to work around this while maintaining your progress.\",\n        'Based on your injury history, I recommend focusing on unilateral exercises and avoiding movements that aggravate the area.',\n        \"It's important to listen to your body. Let's adjust your training load and add some rehabilitation exercises.\",\n      ],\n      schedule: [\n        'I can help you optimize your training schedule based on your availability and goals. What times work best for you?',\n        'Looking at your current schedule, I suggest moving your heavy training days to when you have more time and energy.',\n        \"Let's create a flexible schedule that works with your lifestyle while maintaining consistency.\",\n      ],\n      goal: [\n        \"Your progress looks great! Let's adjust your training to focus on your specific goals and ensure you're on track.\",\n        \"I can see you're making steady progress. Let's set some short-term milestones to keep you motivated.\",\n        \"Based on your current trajectory, you're on track to reach your goals. Let's fine-tune your approach for optimal results.\",\n      ],\n    };\n\n    // Determine response category\n    const category = this.categorizeResponse(userInput);\n    const categoryResponses = responses[category] || responses.workout;\n\n    // Get user context for deterministic selection\n    const userContext = this.getUserContextForFallback();\n\n    // Deterministic selection based on user context\n    const selectedIndex = this.selectDeterministicResponse(categoryResponses, userContext);\n\n    // Return selected response with metadata\n    return {\n      message: categoryResponses[selectedIndex],\n      responseMetadata: {\n        selectionCriteria: userContext,\n        category,\n        selectedIndex,\n        totalOptions: categoryResponses.length,\n        selectionMethod: 'deterministic_context_based',\n      },\n    };\n  }\n\n  // Get user context for deterministic fallback selection\n  getUserContextForFallback() {\n    const userProfile = this.getUserProfile();\n    const recentWorkouts = this.getRecentWorkouts();\n    const currentGoals = this.getCurrentGoals();\n\n    return {\n      goals: currentGoals.primary || 'general_fitness',\n      lastWorkoutType: recentWorkouts.length > 0 ? recentWorkouts[0].type : 'none',\n      readinessScore: this.calculateReadinessScore(),\n      experienceLevel: userProfile.personalData?.experience || 'intermediate',\n      trainingFrequency: this.calculateTrainingFrequency(),\n      currentPhase: this.getCurrentTrainingPhase(),\n    };\n  }\n\n  // Calculate readiness score based on recent activity\n  calculateReadinessScore() {\n    const recentWorkouts = this.getRecentWorkouts();\n    if (recentWorkouts.length === 0) {\n      return 0.8;\n    } // Default moderate readiness\n\n    const lastWorkout = recentWorkouts[0];\n    const daysSinceLastWorkout =\n      (Date.now() - new Date(lastWorkout.start_at).getTime()) / (1000 * 60 * 60 * 24);\n\n    // Simple readiness calculation based on time since last workout\n    if (daysSinceLastWorkout >= 3) {\n      return 0.9;\n    } // High readiness\n    if (daysSinceLastWorkout >= 1) {\n      return 0.7;\n    } // Moderate readiness\n    return 0.4; // Low readiness (same day)\n  }\n\n  // Calculate training frequency (workouts per week)\n  calculateTrainingFrequency() {\n    const recentWorkouts = this.getRecentWorkouts(14); // Last 2 weeks\n    return recentWorkouts.length / 2; // workouts per week\n  }\n\n  // Deterministic response selection based on context\n  selectDeterministicResponse(categoryResponses, userContext) {\n    // Create a deterministic seed based on user context\n    const seed = this.createDeterministicSeed(userContext);\n\n    // Use seed to select response index\n    const selectedIndex = seed % categoryResponses.length;\n\n    return selectedIndex;\n  }\n\n  // Create deterministic seed from user context\n  createDeterministicSeed(userContext) {\n    // Combine multiple context factors into a deterministic seed\n    const contextString = [\n      userContext.goals,\n      userContext.lastWorkoutType,\n      userContext.experienceLevel,\n      userContext.currentPhase,\n      Math.floor(userContext.readinessScore * 10), // Convert to integer\n      Math.floor(userContext.trainingFrequency * 10), // Convert to integer\n    ].join('_');\n\n    // Simple hash function to convert string to number\n    let hash = 0;\n    for (let i = 0; i < contextString.length; i++) {\n      const char = contextString.charCodeAt(i);\n      hash = (hash << 5) - hash + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n\n    return Math.abs(hash);\n  }\n\n  // Helper methods\n  generateCacheKey(userInput, _context) {\n    return userInput\n      .toLowerCase()\n      .replace(/[^a-z0-9]/g, '')\n      .substring(0, 50);\n  }\n\n  getCachedResponse(key) {\n    const cached = this.cache.get(key);\n    if (cached && Date.now() - cached.timestamp < this.cacheExpiry) {\n      return cached.response;\n    }\n    return null;\n  }\n\n  cacheResponse(key, response) {\n    this.cache.set(key, {\n      response,\n      timestamp: Date.now(),\n    });\n  }\n\n  selectOptimalModel(query, context) {\n    // Simple model selection based on query complexity\n    const complexity = this.assessQueryComplexity(query, context);\n\n    if (complexity <= 2) {\n      return 'gpt-3.5-turbo';\n    }\n    if (complexity <= 5) {\n      return 'gpt-4-turbo';\n    }\n    return 'gpt-4';\n  }\n\n  assessQueryComplexity(query, context) {\n    let complexity = 1;\n\n    if (query.length > 500) {\n      complexity += 2;\n    }\n    if (query.length > 1000) {\n      complexity += 2;\n    }\n    if (context.workoutHistory && context.workoutHistory.length > 10) {\n      complexity += 1;\n    }\n    if (context.goals && Object.keys(context.goals).length > 3) {\n      complexity += 1;\n    }\n    if (context.seasonalContext) {\n      complexity += 1;\n    }\n\n    return Math.min(complexity, 10);\n  }\n\n  trackCost(model, _inputTokens, _outputTokens) {\n    this.costTracker.totalCost += 0.001; // Simulated cost\n    this.costTracker.calls++;\n\n    if (!this.costTracker.modelUsage[model]) {\n      this.costTracker.modelUsage[model] = { calls: 0, cost: 0 };\n    }\n    this.costTracker.modelUsage[model].calls++;\n    this.costTracker.modelUsage[model].cost += 0.001;\n  }\n\n  // Get user insights\n  getUserInsights() {\n    return {\n      totalInteractions: this.userHistory.interactions.length,\n      mostCommonTopics: this.getMostCommonTopics(),\n      responseEffectiveness: this.calculateResponseEffectiveness(),\n      patterns: this.patterns,\n      costSummary: this.costTracker,\n    };\n  }\n\n  getMostCommonTopics() {\n    const topics = {};\n    this.userHistory.interactions.forEach(interaction => {\n      const category = this.categorizeResponse(interaction.userInput);\n      topics[category] = (topics[category] || 0) + 1;\n    });\n\n    return Object.entries(topics)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 5)\n      .map(([topic, count]) => ({ topic, count }));\n  }\n\n  calculateResponseEffectiveness() {\n    return {\n      averageRating: 4.2,\n      completionRate: 0.85,\n      userSatisfaction: 0.78,\n    };\n  }\n\n  // Build comprehensive user context for AI\n  buildUserContext() {\n    const user = this.getCurrentUser();\n    if (!user) {\n      return {};\n    }\n\n    const context = {\n      // Basic profile\n      profile: {\n        age: user.personalData?.age,\n        weight: user.personalData?.weight,\n        height: user.personalData?.height,\n        experience: user.personalData?.experience,\n        goals: user.goals,\n      },\n\n      // Recent activity\n      recentWorkouts: this.getRecentWorkouts(7), // Last 7 days\n      recentSessions: this.getRecentSessions(14), // Last 14 days\n\n      // Patterns and insights\n      patterns: this.patternDetector?.getUserPatterns() || {},\n      preferences: this.detectUserPreferences(),\n\n      // Current state\n      currentPhase: this.getCurrentTrainingPhase(),\n      lastWorkout: this.getLastWorkout(),\n      nextScheduled: this.getNextScheduledWorkout(),\n\n      // Performance metrics\n      performance: {\n        averageRPE: this.calculateAverageRPE(),\n        volumeTrend: this.calculateVolumeTrend(),\n        consistency: this.calculateConsistency(),\n        progression: this.calculateProgression(),\n      },\n\n      // Contextual factors\n      timeOfDay: new Date().getHours(),\n      dayOfWeek: new Date().getDay(),\n      season: this.getCurrentSeason(),\n      weather: this.getWeatherContext(),\n\n      // AI interaction history\n      recentQueries: this.getRecentQueries(10),\n      successfulRecommendations: this.getSuccessfulRecommendations(),\n\n      // System state\n      lastSync: this.getLastSyncTime(),\n      offlineMode: !navigator.onLine,\n      dataQuality: this.assessDataQuality(),\n    };\n\n    return context;\n  }\n\n  // Detect user preferences from behavior\n  detectUserPreferences() {\n    const workouts = this.getRecentWorkouts(30);\n    const preferences = {\n      preferredTimes: this.analyzePreferredWorkoutTimes(workouts),\n      favoriteExercises: this.analyzeFavoriteExercises(workouts),\n      intensityPreference: this.analyzeIntensityPreference(workouts),\n      sessionLength: this.analyzePreferredSessionLength(workouts),\n      restDayPattern: this.analyzeRestDayPattern(workouts),\n    };\n\n    return preferences;\n  }\n\n  // Get current training phase\n  getCurrentTrainingPhase() {\n    const user = this.getCurrentUser();\n    if (!user) {\n      return 'off-season';\n    }\n\n    // This would integrate with seasonal training system\n    return user.trainingPhase || 'off-season';\n  }\n\n  // Get last workout details\n  getLastWorkout() {\n    const workouts = this.getRecentWorkouts(1);\n    return workouts[0] || null;\n  }\n\n  // Get next scheduled workout\n  getNextScheduledWorkout() {\n    const user = this.getCurrentUser();\n    if (!user?.workoutPlan) {\n      return null;\n    }\n\n    const today = new Date();\n    const tomorrow = new Date(today);\n    tomorrow.setDate(tomorrow.getDate() + 1);\n\n    // Find next scheduled workout\n    for (let i = 0; i < 7; i++) {\n      const checkDate = new Date(today);\n      checkDate.setDate(checkDate.getDate() + i);\n      const dayPlan = user.workoutPlan[checkDate.getDay()];\n      if (dayPlan && dayPlan.sessions && dayPlan.sessions.length > 0) {\n        return {\n          date: checkDate,\n          sessions: dayPlan.sessions,\n        };\n      }\n    }\n\n    return null;\n  }\n\n  // Calculate average RPE from recent workouts\n  calculateAverageRPE() {\n    const workouts = this.getRecentWorkouts(14);\n    if (workouts.length === 0) {\n      return 0;\n    }\n\n    const totalRPE = workouts.reduce((sum, workout) => {\n      return sum + (workout.averageRPE || 0);\n    }, 0);\n\n    return totalRPE / workouts.length;\n  }\n\n  // Calculate volume trend\n  calculateVolumeTrend() {\n    const workouts = this.getRecentWorkouts(14);\n    if (workouts.length < 2) {\n      return 'stable';\n    }\n\n    const recent = workouts.slice(0, 7);\n    const older = workouts.slice(7, 14);\n\n    const recentVolume = this.calculateTotalVolume(recent);\n    const olderVolume = this.calculateTotalVolume(older);\n\n    const change = (recentVolume - olderVolume) / olderVolume;\n\n    if (change > 0.1) {\n      return 'increasing';\n    }\n    if (change < -0.1) {\n      return 'decreasing';\n    }\n    return 'stable';\n  }\n\n  // Calculate workout consistency\n  calculateConsistency() {\n    const workouts = this.getRecentWorkouts(30);\n    const expectedWorkouts = 30; // Assuming daily workouts\n    const actualWorkouts = workouts.length;\n\n    return actualWorkouts / expectedWorkouts;\n  }\n\n  // Calculate progression rate\n  calculateProgression() {\n    const workouts = this.getRecentWorkouts(30);\n    if (workouts.length < 2) {\n      return 0;\n    }\n\n    // Simple progression calculation based on weight increases\n    let progressionCount = 0;\n    for (let i = 1; i < workouts.length; i++) {\n      const current = workouts[i];\n      const previous = workouts[i - 1];\n\n      if (current.averageWeight > previous.averageWeight) {\n        progressionCount++;\n      }\n    }\n\n    return progressionCount / (workouts.length - 1);\n  }\n\n  // Get recent sessions (all types)\n  getRecentSessions(days) {\n    const user = this.getCurrentUser();\n    if (!user?.data?.sessions) {\n      return [];\n    }\n\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - days);\n\n    return user.data.sessions\n      .filter(session => {\n        const sessionDate = new Date(session.start_at);\n        return sessionDate >= cutoffDate;\n      })\n      .sort((a, b) => new Date(b.start_at) - new Date(a.start_at));\n  }\n\n  // Analyze preferred workout times\n  analyzePreferredWorkoutTimes(workouts) {\n    const timeCounts = {};\n    workouts.forEach(workout => {\n      const hour = new Date(workout.start_at).getHours();\n      const timeSlot = hour < 12 ? 'morning' : hour < 17 ? 'afternoon' : 'evening';\n      timeCounts[timeSlot] = (timeCounts[timeSlot] || 0) + 1;\n    });\n\n    return Object.entries(timeCounts)\n      .sort(([, a], [, b]) => b - a)\n      .map(([time, count]) => ({ time, count }));\n  }\n\n  // Analyze favorite exercises\n  analyzeFavoriteExercises(workouts) {\n    const exerciseCounts = {};\n    workouts.forEach(workout => {\n      if (workout.exercises) {\n        workout.exercises.forEach(exercise => {\n          exerciseCounts[exercise.name] = (exerciseCounts[exercise.name] || 0) + 1;\n        });\n      }\n    });\n\n    return Object.entries(exerciseCounts)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 10)\n      .map(([exercise, count]) => ({ exercise, count }));\n  }\n\n  // Analyze intensity preference\n  analyzeIntensityPreference(workouts) {\n    const rpeValues = workouts.map(w => w.averageRPE).filter(rpe => rpe > 0);\n    if (rpeValues.length === 0) {\n      return 'moderate';\n    }\n\n    const averageRPE = rpeValues.reduce((sum, rpe) => sum + rpe, 0) / rpeValues.length;\n\n    if (averageRPE >= 8) {\n      return 'high';\n    }\n    if (averageRPE <= 5) {\n      return 'low';\n    }\n    return 'moderate';\n  }\n\n  // Analyze preferred session length\n  analyzePreferredSessionLength(workouts) {\n    const durations = workouts.map(w => w.duration).filter(d => d > 0);\n    if (durations.length === 0) {\n      return 60;\n    } // Default 60 minutes\n\n    const averageDuration = durations.reduce((sum, d) => sum + d, 0) / durations.length;\n\n    if (averageDuration <= 30) {\n      return 'short';\n    }\n    if (averageDuration <= 60) {\n      return 'medium';\n    }\n    return 'long';\n  }\n\n  // Analyze rest day pattern\n  analyzeRestDayPattern(workouts) {\n    const workoutDays = workouts.map(w => new Date(w.start_at).getDay());\n    const dayCounts = {};\n\n    for (let i = 0; i < 7; i++) {\n      dayCounts[i] = workoutDays.filter(day => day === i).length;\n    }\n\n    return dayCounts;\n  }\n\n  // Calculate total volume for workouts\n  calculateTotalVolume(workouts) {\n    return workouts.reduce((total, workout) => {\n      if (workout.exercises) {\n        return (\n          total +\n          workout.exercises.reduce((exerciseTotal, exercise) => {\n            return exerciseTotal + exercise.weight * exercise.reps * exercise.sets;\n          }, 0)\n        );\n      }\n      return total;\n    }, 0);\n  }\n\n  // Get current season\n  getCurrentSeason() {\n    const month = new Date().getMonth();\n    if (month >= 2 && month <= 4) {\n      return 'spring';\n    }\n    if (month >= 5 && month <= 7) {\n      return 'summer';\n    }\n    if (month >= 8 && month <= 10) {\n      return 'fall';\n    }\n    return 'winter';\n  }\n\n  // Get weather context (placeholder)\n  getWeatherContext() {\n    // This would integrate with a weather API\n    return {\n      temperature: 'moderate',\n      conditions: 'clear',\n      humidity: 'normal',\n    };\n  }\n\n  // Get recent AI queries\n  getRecentQueries(count) {\n    return this.interactionHistory\n      .slice(-count)\n      .map(interaction => interaction.query)\n      .reverse();\n  }\n\n  // Get successful recommendations\n  getSuccessfulRecommendations() {\n    return this.interactionHistory\n      .filter(interaction => interaction.rating >= 4)\n      .map(interaction => interaction.response)\n      .slice(-5);\n  }\n\n  // Get last sync time\n  getLastSyncTime() {\n    return localStorage.getItem('ignitefitness_last_sync') || null;\n  }\n\n  // Assess data quality\n  assessDataQuality() {\n    const user = this.getCurrentUser();\n    if (!user) {\n      return 'poor';\n    }\n\n    let score = 0;\n\n    // Check profile completeness\n    if (user.personalData?.age) {\n      score += 1;\n    }\n    if (user.personalData?.weight) {\n      score += 1;\n    }\n    if (user.personalData?.height) {\n      score += 1;\n    }\n    if (user.goals?.primary) {\n      score += 1;\n    }\n\n    // Check workout data\n    const workoutCount = user.data?.sessions?.filter(s => s.type === 'workout').length || 0;\n    if (workoutCount >= 10) {\n      score += 2;\n    } else if (workoutCount >= 5) {\n      score += 1;\n    }\n\n    if (score >= 6) {\n      return 'excellent';\n    }\n    if (score >= 4) {\n      return 'good';\n    }\n    if (score >= 2) {\n      return 'fair';\n    }\n    return 'poor';\n  }\n\n  // Get current user from global state\n  getCurrentUser() {\n    // This would integrate with the main app's user management\n    const currentUser = localStorage.getItem('ignitefitness_current_user');\n    if (!currentUser) {\n      return null;\n    }\n\n    const users = JSON.parse(localStorage.getItem('ignitefitness_users') || '{}');\n    return users[currentUser] || null;\n  }\n\n  // Analyze query complexity\n  analyzeQueryComplexity(query, context) {\n    const queryLength = query.length;\n    const wordCount = query.split(' ').length;\n    const hasQuestions = query.includes('?');\n    const hasTechnicalTerms = this.hasTechnicalTerms(query);\n    const requiresAnalysis = this.requiresAnalysis(query);\n    const requiresExpertise = this.requiresExpertise(query);\n\n    let complexityScore = 0;\n\n    // Length factors\n    if (queryLength > 500) {\n      complexityScore += 2;\n    } else if (queryLength > 200) {\n      complexityScore += 1;\n    }\n\n    // Word count factors\n    if (wordCount > 50) {\n      complexityScore += 2;\n    } else if (wordCount > 20) {\n      complexityScore += 1;\n    }\n\n    // Content factors\n    if (hasTechnicalTerms) {\n      complexityScore += 2;\n    }\n    if (requiresAnalysis) {\n      complexityScore += 3;\n    }\n    if (requiresExpertise) {\n      complexityScore += 3;\n    }\n    if (hasQuestions) {\n      complexityScore += 1;\n    }\n\n    // Context factors\n    if (context.requiresExpertise) {\n      complexityScore += 2;\n    }\n    if (context.requiresAnalysis) {\n      complexityScore += 2;\n    }\n    if (context.queryType === 'injury') {\n      complexityScore += 3;\n    }\n    if (context.queryType === 'research') {\n      complexityScore += 4;\n    }\n\n    // Determine complexity level\n    if (complexityScore >= 8) {\n      return { level: 'expert', score: complexityScore };\n    }\n    if (complexityScore >= 5) {\n      return { level: 'complex', score: complexityScore };\n    }\n    if (complexityScore >= 2) {\n      return { level: 'standard', score: complexityScore };\n    }\n    return { level: 'simple', score: complexityScore };\n  }\n\n  // Check if query contains technical terms\n  hasTechnicalTerms(query) {\n    const technicalTerms = [\n      'rpe',\n      'rm',\n      '1rm',\n      'volume',\n      'intensity',\n      'periodization',\n      'hypertrophy',\n      'strength',\n      'endurance',\n      'power',\n      'speed',\n      'agility',\n      'flexibility',\n      'mobility',\n      'stability',\n      'balance',\n      'proprioception',\n      'kinesthetic',\n      'biomechanics',\n      'physiology',\n      'metabolism',\n      'hormones',\n      'recovery',\n      'adaptation',\n      'overload',\n      'progression',\n      'regression',\n      'deload',\n      'taper',\n      'peaking',\n    ];\n\n    const lowerQuery = query.toLowerCase();\n    return technicalTerms.some(term => lowerQuery.includes(term));\n  }\n\n  // Check if query requires analysis\n  requiresAnalysis(query) {\n    const analysisKeywords = [\n      'analyze',\n      'analysis',\n      'compare',\n      'evaluate',\n      'assess',\n      'review',\n      'examine',\n      'study',\n      'research',\n      'investigate',\n      'why',\n      'how',\n      'what if',\n      'explain',\n      'describe in detail',\n    ];\n\n    const lowerQuery = query.toLowerCase();\n    return analysisKeywords.some(keyword => lowerQuery.includes(keyword));\n  }\n\n  // Check if query requires expertise\n  requiresExpertise(query) {\n    const expertiseKeywords = [\n      'injury',\n      'pain',\n      'rehabilitation',\n      'therapy',\n      'medical',\n      'doctor',\n      'physician',\n      'therapist',\n      'specialist',\n      'expert',\n      'diagnosis',\n      'treatment',\n      'condition',\n      'symptom',\n      'recovery',\n      'prevention',\n      'risk',\n      'safety',\n      'warning',\n      'caution',\n    ];\n\n    const lowerQuery = query.toLowerCase();\n    return expertiseKeywords.some(keyword => lowerQuery.includes(keyword));\n  }\n\n  // Call AI API (mock implementation)\n  async callAIAPI(prompt, selectedModel) {\n    // This would make actual API calls to the selected model\n    // For now, return a mock response\n\n    const mockResponses = {\n      'claude-haiku': `Quick response for: \"${prompt.substring(0, 50)}...\"`,\n      'gpt-3.5-turbo': `Standard response for: \"${prompt.substring(0, 50)}...\"`,\n      'claude-sonnet': `Detailed response for: \"${prompt.substring(0, 50)}...\"`,\n      'claude-opus': `Expert analysis for: \"${prompt.substring(0, 50)}...\"`,\n    };\n\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    return mockResponses[selectedModel.name.toLowerCase().replace(' ', '-')] || 'AI response';\n  }\n\n  // Generate fallback response\n  generateFallbackResponse(userInput, selectedModel) {\n    const fallbackResponses = {\n      'claude-haiku': 'I understand your question. Let me provide a quick answer.',\n      'gpt-3.5-turbo': \"I can help you with that. Here's what I recommend.\",\n      'claude-sonnet': \"That's an interesting question. Let me give you a detailed response.\",\n      'claude-opus': 'This requires expert analysis. Let me provide comprehensive guidance.',\n    };\n\n    return (\n      fallbackResponses[selectedModel.name.toLowerCase().replace(' ', '-')] || \"I'm here to help!\"\n    );\n  }\n\n  // Track model usage for cost optimization\n  trackModelUsage(model, inputTokens, outputTokens) {\n    if (!this.modelUsage) {\n      this.modelUsage = {};\n    }\n\n    const modelKey = model.name.toLowerCase().replace(' ', '-');\n    if (!this.modelUsage[modelKey]) {\n      this.modelUsage[modelKey] = {\n        calls: 0,\n        inputTokens: 0,\n        outputTokens: 0,\n        totalCost: 0,\n      };\n    }\n\n    const usage = this.modelUsage[modelKey];\n    usage.calls++;\n    usage.inputTokens += inputTokens;\n    usage.outputTokens += outputTokens;\n    usage.totalCost += this.calculateCost(inputTokens, outputTokens, model.costPer1kTokens);\n\n    // Save to localStorage\n    localStorage.setItem('ignitefitness_model_usage', JSON.stringify(this.modelUsage));\n  }\n\n  // Calculate cost for model usage\n  calculateCost(inputTokens, outputTokens, costPer1kTokens) {\n    const totalTokens = inputTokens + outputTokens;\n    return (totalTokens / 1000) * costPer1kTokens;\n  }\n\n  // Get model usage statistics\n  getModelUsageStats() {\n    return this.modelUsage || {};\n  }\n\n  // Estimate cost for a query\n  estimateCost(query, response, selectedModel) {\n    const inputTokens = Math.ceil(query.length / 4); // Rough estimation\n    const outputTokens = Math.ceil(response.length / 4);\n    return this.calculateCost(inputTokens, outputTokens, selectedModel.costPer1kTokens);\n  }\n}\n\n// Export for use in other modules\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = { ContextAwareAI };\n} else {\n  // Make available globally for browser\n  window.ContextAwareAI = ContextAwareAI;\n}\n"],"names":["ContextAwareAI","constructor","this","logger","window","SafeLogger","console","userHistory","loadUserHistory","patterns","loadPatterns","successMetrics","loadSuccessMetrics","cache","Map","cacheExpiry","contextWindow","costTracker","totalCost","calls","modelUsage","history","localStorage","getItem","JSON","parse","interactions","preferences","lastUpdated","Date","now","error","message","stack","workoutPreferences","responsePatterns","successPatterns","failurePatterns","metrics","workoutCompletions","goalAchievements","userSatisfaction","responseEffectiveness","saveUserHistory","setItem","stringify","savePatterns","saveSuccessMetrics","addInteraction","userInput","aiResponse","context","interaction","timestamp","sessionId","getCurrentSessionId","push","length","slice","updatePatterns","sessionStorage","Math","random","toString","substr","input","toLowerCase","response","includes","responseType","categorizeResponse","lowerResponse","getContextualContext","recentInteractions","userProfile","getUserProfile","currentGoals","getCurrentGoals","recentWorkouts","getRecentWorkouts","seasonalContext","getSeasonalContext","userData","goals","sessions","seasonalData","generateContextualPrompt","_context","contextualContext","prompt","name","primary","lastWorkout","type","start_at","toLocaleDateString","phase","map","i","join","p","processUserInput","cacheKey","generateCacheKey","cachedResponse","getCachedResponse","contextualPrompt","selectedModel","selectOptimalModel","getAIResponse","cacheResponse","inputTokens","ceil","outputTokens","trackCost","model","fetch","method","headers","body","endpoint","data","messages","role","content","max_tokens","temperature","ok","_data$choices","json","choices","warn","status","fallbackResult","getFallbackResponse","responses","workout","nutrition","injury","schedule","goal","category","categoryResponses","userContext","getUserContextForFallback","selectedIndex","selectDeterministicResponse","responseMetadata","selectionCriteria","totalOptions","selectionMethod","_userProfile$personal","lastWorkoutType","readinessScore","calculateReadinessScore","experienceLevel","personalData","experience","trainingFrequency","calculateTrainingFrequency","currentPhase","getCurrentTrainingPhase","daysSinceLastWorkout","getTime","createDeterministicSeed","contextString","floor","hash","charCodeAt","abs","replace","substring","key","cached","get","set","query","complexity","assessQueryComplexity","workoutHistory","Object","keys","min","_inputTokens","_outputTokens","cost","getUserInsights","totalInteractions","mostCommonTopics","getMostCommonTopics","calculateResponseEffectiveness","costSummary","topics","forEach","entries","sort","a","b","topic","count","averageRating","completionRate","buildUserContext","_user$personalData","_user$personalData2","_user$personalData3","_user$personalData4","_this$patternDetector","user","getCurrentUser","profile","age","weight","height","recentSessions","getRecentSessions","patternDetector","getUserPatterns","detectUserPreferences","getLastWorkout","nextScheduled","getNextScheduledWorkout","performance","averageRPE","calculateAverageRPE","volumeTrend","calculateVolumeTrend","consistency","calculateConsistency","progression","calculateProgression","timeOfDay","getHours","dayOfWeek","getDay","season","getCurrentSeason","weather","getWeatherContext","recentQueries","getRecentQueries","successfulRecommendations","getSuccessfulRecommendations","lastSync","getLastSyncTime","offlineMode","navigator","onLine","dataQuality","assessDataQuality","workouts","preferredTimes","analyzePreferredWorkoutTimes","favoriteExercises","analyzeFavoriteExercises","intensityPreference","analyzeIntensityPreference","sessionLength","analyzePreferredSessionLength","restDayPattern","analyzeRestDayPattern","trainingPhase","workoutPlan","today","tomorrow","setDate","getDate","checkDate","dayPlan","date","reduce","sum","recent","older","recentVolume","calculateTotalVolume","olderVolume","change","progressionCount","current","previous","averageWeight","days","_user$data","cutoffDate","filter","session","timeCounts","hour","timeSlot","time","exerciseCounts","exercises","exercise","rpeValues","w","rpe","durations","duration","d","averageDuration","workoutDays","dayCounts","day","total","exerciseTotal","reps","sets","month","getMonth","conditions","humidity","interactionHistory","reverse","rating","_user$personalData5","_user$personalData6","_user$personalData7","_user$goals","_user$data2","score","workoutCount","s","currentUser","analyzeQueryComplexity","queryLength","wordCount","split","hasQuestions","complexityScore","hasTechnicalTerms","requiresAnalysis","requiresExpertise","queryType","level","lowerQuery","some","term","keyword","callAIAPI","mockResponses","Promise","resolve","setTimeout","generateFallbackResponse","trackModelUsage","modelKey","usage","calculateCost","costPer1kTokens","getModelUsageStats","estimateCost","module","exports"],"sourceRoot":""}