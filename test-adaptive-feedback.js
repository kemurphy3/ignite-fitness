/**
 * Adaptive Feedback Loop Test Suite
 * Tests 12 scenarios for adaptive workout prescriptions
 */

class AdaptiveFeedbackTest {
    constructor() {
        this.loadController = new LoadController();
        this.sessionLogger = new SessionOutcomeLogger();
        this.progressionEngine = new ProgressionEngine();
        
        this.results = {
            passed: [],
            failed: [],
            total: 0
        };
    }

    /**
     * Run all scenario tests
     */
    async runAllTests() {
        console.log('🧪 Running Adaptive Feedback Loop Tests...\n');
        
        // Test scenarios
        await this.testLowReadiness();
        await this.testMissedCheckIn();
        await this.testHardGameYesterday();
        await this.testDeloadWeek();
        await this.testRPE8FullVolume();
        await this.testRPE9FailedReps();
        await this.testRPE7Moderate();
        await this.testRPE5Easy();
        await this.testKneePain();
        await this.testMultipleConflicts();
        await this.testInferredReadiness();
        await this.testPrescriptionPersistence();
        
        this.printResults();
    }

    /**
     * Test: Low readiness (≤4)
     * Expected: Recovery session, reduced load
     */
    async testLowReadiness() {
        try {
            const adjustments = await this.progressionEngine.adjustLoadFromRPE(
                'test_user',
                { id: 'test_workout', type: 'strength' },
                7
            );
            
            // Simulate low readiness
            const readinessAdj = {
                intensityMultiplier: 0.5,
                workoutType: 'recovery',
                coachMessage: 'Low readiness - recovery session'
            };
            
            const result = await this.loadController.processSessionCompletion({
                userId: 'test_user',
                readinessBefore: 3,
                exercises: [{ rpe: 5, completed: true }]
            });
            
            this.results.passed.push('Scenario 1: Low readiness → Recovery session');
            this.results.total++;
        } catch (error) {
            this.results.failed.push({ scenario: 'Low readiness', error: error.message });
            this.results.total++;
        }
    }

    /**
     * Test: Missed check-in
     * Expected: Readiness inferred from yesterday's RPE and volume
     */
    async testMissedCheckIn() {
        try {
            const yesterdaySession = {
                averageRPE: 8,
                totalVolume: 5000,
                completionRate: 1.0
            };
            
            // LoadController should infer readiness
            const inferredReadiness = this.loadController.inferReadiness(
                yesterdaySession,
                0,
                []
            );
            
            if (inferredReadiness && inferredReadiness <= 7) {
                this.results.passed.push('Scenario 2: Missed check-in → Readiness inferred');
                this.results.total++;
            } else {
                this.results.failed.push({ scenario: 'Missed check-in', reason: 'Inference not working' });
                this.results.total++;
            }
        } catch (error) {
            this.results.failed.push({ scenario: 'Missed check-in', error: error.message });
            this.results.total++;
        }
    }

    /**
     * Test: Hard game yesterday
     * Expected: Lower readiness inferred, reduced load
     */
    async testHardGameYesterday() {
        try {
            const gameSession = {
                averageRPE: 9,
                totalVolume: 8000,
                completionRate: 1.0,
                type: 'game'
            };
            
            const inferredReadiness = this.loadController.inferReadiness(gameSession, 0, []);
            
            if (inferredReadiness <= 5) {
                this.results.passed.push('Scenario 3: Hard game yesterday → Lower readiness');
                this.results.total++;
            } else {
                this.results.failed.push({ scenario: 'Hard game yesterday', reason: 'Readiness not reduced enough' });
                this.results.total++;
            }
        } catch (error) {
            this.results.failed.push({ scenario: 'Hard game yesterday', error: error.message });
            this.results.total++;
        }
    }

    /**
     * Test: Deload week
     * Expected: -20% volume, every 4th week
     */
    async testDeloadWeek() {
        try {
            const deloadAdj = this.progressionEngine.getDeloadAdjustments();
            
            if (deloadAdj.volumeMultiplier === 0.80 && deloadAdj.deload === true) {
                this.results.passed.push('Scenario 4: Deload week → -20% volume');
                this.results.total++;
            } else {
                this.results.failed.push({ scenario: 'Deload week', reason: 'Volume reduction incorrect' });
                this.results.total++;
            }
        } catch (error) {
            this.results.failed.push({ scenario: 'Deload week', error: error.message });
            this.results.total++;
        }
    }

    /**
     * Test: RPE ≥ 8 with full volume
     * Expected: +2.5% load next time
     */
    async testRPE8FullVolume() {
        try {
            const sessionData = {
                userId: 'test_user',
                averageRPE: 8.5,
                totalVolume: 6000,
                exercises: [{ rpe: 8, completed: true }, { rpe: 9, completed: true }]
            };
            
            const recommendations = this.sessionLogger.generateRecommendations({
                averageRPE: 8.5,
                completionRate: 1.0
            });
            
            if (recommendations.loadChange === 0 || recommendations.loadChange > 0) {
                this.results.passed.push('Scenario 5: RPE ≥ 8 full volume → Load maintained/increased');
                this.results.total++;
            } else {
                this.results.failed.push({ scenario: 'RPE 8 full volume', reason: 'Load adjustment incorrect' });
                this.results.total++;
            }
        } catch (error) {
            this.results.failed.push({ scenario: 'RPE 8 full volume', error: error.message });
            this.results.total++;
        }
    }

    /**
     * Test: RPE ≥ 9 or failed reps
     * Expected: -5% load or reduce volume
     */
    async testRPE9FailedReps() {
        try {
            const recommendations = this.sessionLogger.generateRecommendations({
                averageRPE: 9.5,
                completionRate: 0.7 // Failed some reps
            });
            
            if (recommendations.loadChange < 0 || recommendations.volumeChange < 0) {
                this.results.passed.push('Scenario 6: RPE ≥ 9 or failed reps → Reduce load/volume');
                this.results.total++;
            } else {
                this.results.failed.push({ scenario: 'RPE 9 failed reps', reason: 'No load reduction' });
                this.results.total++;
            }
        } catch (error) {
            this.results.failed.push({ scenario: 'RPE 9 failed reps', error: error.message });
            this.results.total++;
        }
    }

    /**
     * Test: RPE 7 moderate
     * Expected: Maintain load or slight increase
     */
    async testRPE7Moderate() {
        try {
            const recommendations = this.sessionLogger.generateRecommendations({
                averageRPE: 7.0,
                completionRate: 1.0
            });
            
            if (recommendations.loadChange >= 0 && recommendations.loadChange <= 0.05) {
                this.results.passed.push('Scenario 7: RPE 7 moderate → Maintain or slightly increase load');
                this.results.total++;
            } else {
                this.results.failed.push({ scenario: 'RPE 7 moderate', reason: 'Load adjustment incorrect' });
                this.results.total++;
            }
        } catch (error) {
            this.results.failed.push({ scenario: 'RPE 7 moderate', error: error.message });
            this.results.total++;
        }
    }

    /**
     * Test: RPE 5 easy
     * Expected: +5% load next time
     */
    async testRPE5Easy() {
        try {
            const recommendations = this.sessionLogger.generateRecommendations({
                averageRPE: 5.0,
                completionRate: 1.0
            });
            
            if (recommendations.loadChange === 0.05) {
                this.results.passed.push('Scenario 8: RPE 5 easy → +5% load next time');
                this.results.total++;
            } else {
                this.results.failed.push({ scenario: 'RPE 5 easy', reason: 'Load increase not +5%' });
                this.results.total++;
            }
        } catch (error) {
            this.results.failed.push({ scenario: 'RPE 5 easy', error: error.message });
            this.results.total++;
        }
    }

    /**
     * Test: Knee pain
     * Expected: Exercise substitution, safety prioritization
     */
    async testKneePain() {
        try {
            const adjustments = await this.loadController.processSessionCompletion({
                userId: 'test_user',
                modifications: [{ type: 'knee_pain', location: 'knee', painLevel: 6 }]
            });
            
            this.results.passed.push('Scenario 9: Knee pain → Exercise substitutions');
            this.results.total++;
        } catch (error) {
            this.results.failed.push({ scenario: 'Knee pain', error: error.message });
            this.results.total++;
        }
    }

    /**
     * Test: Multiple conflicts
     * Expected: All constraints respected
     */
    async testMultipleConflicts() {
        try {
            const adjustments = await this.progressionEngine.getComprehensiveAdjustments(
                'test_user',
                { intensityMultiplier: 0.7, workoutType: 'recovery' },
                { gameDate: new Date(Date.now() + 86400000) },
                4 // Deload week
            );
            
            if (adjustments.modifications && adjustments.modifications.includes('deload_week')) {
                this.results.passed.push('Scenario 10: Multiple conflicts → All constraints respected');
                this.results.total++;
            } else {
                this.results.failed.push({ scenario: 'Multiple conflicts', reason: 'Not all constraints applied' });
                this.results.total++;
            }
        } catch (error) {
            this.results.failed.push({ scenario: 'Multiple conflicts', error: error.message });
            this.results.total++;
        }
    }

    /**
     * Test: Inferred readiness from external data
     * Expected: Readiness calculated from Strava, volume, injuries
     */
    async testInferredReadiness() {
        try {
            const readiness = this.loadController.inferReadiness(
                { averageRPE: 8, totalVolume: 6000 },
                10, // 10% volume increase
                [{ location: 'ankle', active: true }]
            );
            
            if (readiness >= 1 && readiness <= 10) {
                this.results.passed.push('Scenario 11: Inferred readiness from external data');
                this.results.total++;
            } else {
                this.results.failed.push({ scenario: 'Inferred readiness', reason: 'Readiness out of range' });
                this.results.total++;
            }
        } catch (error) {
            this.results.failed.push({ scenario: 'Inferred readiness', error: error.message });
            this.results.total++;
        }
    }

    /**
     * Test: Prescription persistence
     * Expected: Next session loads saved and retrievable
     */
    async testPrescriptionPersistence() {
        try {
            await this.loadController.updateNextSessionLoads('test_user', {
                intensityMultiplier: 1.05,
                volumeMultiplier: 1.0,
                rationales: ['Test rationale']
            });
            
            const prefs = await this.loadController.storageManager.getPreferences('test_user');
            
            if (prefs?.nextSessionConfig) {
                this.results.passed.push('Scenario 12: Prescription persistence → Loads saved and retrievable');
                this.results.total++;
            } else {
                this.results.failed.push({ scenario: 'Prescription persistence', reason: 'Not persisted' });
                this.results.total++;
            }
        } catch (error) {
            this.results.failed.push({ scenario: 'Prescription persistence', error: error.message });
            this.results.total++;
        }
    }

    /**
     * Print test results
     */
    printResults() {
        console.log('\n📊 Test Results Summary');
        console.log(`✅ Passed: ${this.results.passed.length}`);
        console.log(`❌ Failed: ${this.results.failed.length}`);
        console.log(`Total: ${this.results.total}\n`);
        
        this.results.passed.forEach((test, i) => {
            console.log(`${i + 1}. ${test}`);
        });
        
        if (this.results.failed.length > 0) {
            console.log('\nFailed Tests:');
            this.results.failed.forEach((test, i) => {
                console.log(`${i + 1}. ${test.scenario}: ${test.reason || test.error}`);
            });
        }
        
        console.log('\n' + '='.repeat(50));
        if (this.results.failed.length === 0) {
            console.log('✅ ALL 12 SCENARIOS PASSED');
        } else {
            console.log('❌ SOME SCENARIOS FAILED');
        }
        console.log('='.repeat(50));
    }
}

// Export for testing
if (typeof module !== 'undefined' && module.exports) {
    module.exports = AdaptiveFeedbackTest;
}

window.AdaptiveFeedbackTest = AdaptiveFeedbackTest;
